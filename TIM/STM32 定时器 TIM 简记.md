# STM32 定时器 TIM 简记

[![Gralerfics](https://pic1.zhimg.com/v2-13406e3e6084ee7367285c21c9a461a2_l.jpg?source=172ae18b)](https://www.zhihu.com/people/gralerfics)

[Gralerfics](https://www.zhihu.com/people/gralerfics)

菜狗

https://zhuanlan.zhihu.com/p/557896041

目录

收起

一、TIM 外设分类与引脚定义

二、TIM 硬件实现结构

（1）基本定时器

（2）通用定时器

（3）高级定时器

三、TIM 寄存器定义概述

（1）基本定时器

（2）通用定时器

（3）高级定时器

四、具体实现案例（标准库 + HAL）

（1）定时中断

（2）外部时钟源选择

（3）利用输出比较功能输出 PWM 波形

> 简单记录，避免遗忘。

![STM32 定时器 TIM 简记](https://pic1.zhimg.com/v2-4e81f1b0b9285130ba00e85f8bd05cc4_720w.jpg?source=172ae18b)

> 

------

## 一、TIM 外设分类与引脚定义

| 类型       | 编号                   | 总线             | 功能                                                         |
| ---------- | ---------------------- | ---------------- | ------------------------------------------------------------ |
| 高级定时器 | TIM1、TIM8             | APB2（性能更高） | 通用定时器全部功能，并外加重复计数器、死区生成、互补输出、刹车输入等功能 |
| 通用定时器 | TIM2、TIM3、TIM4、TIM5 | APB1             | 基本定时器全部功能，并外加内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能 |
| 基本定时器 | TIM6、TIM7             | APB1             | 定时中断、主模式触发 DAC                                     |

> STM32F103C8T6 拥有 TIM1、TIM2、TIM3 和 TIM4 的定时器，即一个高级定时器和三个通用定时器。







## 二、TIM 硬件实现结构

### （1）**基本定时器**

![img](https://pic2.zhimg.com/80/v2-1c43635365e85947ddc941d2e804191d_720w.webp)

手册中的基本定时器（TIM6、7）结构框图与说明

**【时基单元与定时中断】**图中包含三个寄存器，分别是**预分频器**、**计数器**和**自动重装载寄存器**。它们是设置定时中断最重要、最基础的寄存器。该部分构成了最基本的计数计时电路，被称为时基单元。按顺序简述一下定时的基本原理：

先说一下**分频**：使**输出信号**的频率为**输入信号**的整数分之一倍。实现原理大概是把原始频率的时钟信号间隔采样，分成几份当作几个时钟用，故为分频。例如 72MHz 的原始信号进行二分频的到两个 36MHz 的信号。

**预分频器**：图中时钟信号最先经过的部分。该部分电路就是一个可编程分频器，可将输入的时钟信号按设定好的倍数分频（运行时也可以修改，不过要到下一个计数周期才有效，具体可以见手册时序图例子）。**预分频控制寄存器**（TIMx_PSC）写 0 就是不分频得到 72MHz，写 1 就是二分频得到 36MHz，写 2 就是三分频得到 24MHz，依此类推（所以其值和实际系数是差 1 的）。它是一个 **16 位寄存器**，即最多可以分频为 65536 分之一（65535 + 1）。

> 因为基本定时器不能选择外部时钟源，所以框图中绘制的是内部时钟（CK_INT）的信号流入预分频器，来自 RCC 的 TIMxCLK，其一般为系统主频 72MHz。
> 预分频器其实组成不是那么简单，包括了**预分频控制寄存器**（我们唯一需要管的，用来配置分频系数的寄存器）、**预分频缓冲器**（或影子寄存器，这才是真正起作用的寄存器）和**预分频计数器**（用以实现间隔采样，也就是分频的实现原理）等，它们描述了预分频器的**缓冲机制**。这套缓冲机制决定了为什么修改预分频系数要到下一个计数周期才会其效果，目的是为了保证一个计数周期内的计数频率不会突变。
> 值得注意的是，手册中框图有些寄存器带有**阴影效果**，这就代表这个寄存器拥有类似预分频器那样的**缓冲机制**，即拥有**影子寄存器**。并且有些情况下还可以通过相应的寄存器**设置是否要使用**这套机制，例如自动重装载寄存器。

**计数器**：对**预分频后**的信号（CK_CNT）进行上升沿计数，每一个上升沿则**计数器寄存器**（TIMx_CNT）加一。当寄存器累加到规定的数目（见后自动重装载寄存器）时就**触发中断**，完成定时任务（加到够就跳回 0）。它也是 **16 位寄存器**，即最大可以从 0 数到 65535。

> 这种触发的中断一般称为**更新中断**（Update Interrupt），即框图中的折线箭头 UI。它被送往 NVIC，之后配置好 NVIC 的定时器通道即可处理该中断；另一个向下的折线箭头 U 代表会产生一个**更新事件**，可以协同其它部分电路工作。具体见 [STM32 中断与外部中断 EXTI 简记 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/556317422)。

**自动重装载寄存器**（TIMx_ARR）：它存储的就是计数器的**目标值**，计数器每次累加就比较二者，二者相等就触发中断，然后清零计数器寄存器。它也是一个 **16 位寄存器**，因为和计数器物理意义上同步相关。

> 所以我们可以算一下单个 TIM 最多可以定多久的时。我们将**预分频寄存器**和**自动重装载寄存器**都调到 65535，设原始时钟信号是最大主频 72MHz。那么也就是首先经过 65536 分频，然后每计数到 65535 触发一次中断，**最长计时时间**即为 



>  。
> 当然，TIM 还可以**级联**（一个 TIM 的输出接到另一个的输入），如果两个拉满的 TIM 级联起来，那么又可以把这个时间延长到八千多年。

**还有一些细节上的问题，可以参考手册中的大量时序图样例。**

> **【相关参数和物理量的关系计算】**
> 溢出频率 CK_CNT_OV = CK_PSC / (PSC + 1) / (ARR + 1)
> 计数频率 CK_CNT = CK_PSC / (PSC + 1)

以上是定时中断的原理，表中可见基本定时器还有一个主模式触发 DAC 功能：

**【主模式触发 DAC】**DAC 是 STM32 的**数模转换器**外设，使用它经常会需要间隔一段固定的采样时间输出下一个电压值的情况。要完成这个操作，**最基础**可以用定时中断实现：即定时采样间隔，然后在中断处理中手动触发 DAC 转换，输出下一个电压值。这样的缺点也很明显，就是 CPU **会频繁地被中断**。解决的方法就是中断章节中提过的**事件触发**方式，即 STM32 通过硬件线路，将更新事件 U 通过主模式映射到了图中的 TRGO，TRGO 直接连接到 DAC，由它去触发 DAC，不用软件干预。

> 主模式的含义大概就是 TIM 作为触发的一方去主动触发 DAC。







### （2）通用定时器

![img](https://pic4.zhimg.com/80/v2-55e9cf58f7538b18c8c6d8d3baf2545f_720w.webp)

手册中通用定时器（TIM2、3、4、5）的结构框图

**【时基单元】**最基本的结构还是时基单元，和基本定时器是一样的（即上述的包含基本定时器所有功能）。在框图中正中偏右的位置。以此为参考可以将框图分区阅读。

**【计数器模式】**基本定时器中只提到了计数器向上累加，到顶置零，这是向上计数模式。通用定时器除此之外还有向下计数模式和中央对齐模式。向下计数模式就是从重装值开始减到 0 结束一轮，然后跳回重装值；中央对齐模式就是交替着来，增到顶触发，然后开始减，减到 0 又触发，再增。其实最常用的还是向上计数。

> 体现在框图中就是时基单元那里那一行“停止、清除或向上 / 向下”。可以看到对应的基本定时器的框图中就是“停止、清除或向上”，没有向下。中央对齐模式也称为向上 / 向下计数模式，包含在其中了。

**【时钟选择】**通用定时器支持内外时钟源选择，不同于基本定时器只能接收内部时钟信号。这部分电路就是框图中时基单元往上的其中一部分。

依次看可以看到，首先通用定时器也可以选择内部时钟（第一条线，来自 RCC 的 TIMxCLK），也就是“**内部时钟模式**”。

然后还可以选择外部时钟，看最左侧它来自 TIMx_ETR。这意味着我们可以给这个 TIMx_ETR 对应的引脚接入外部时钟供定时器使用。这个外部时钟也就是一个方波信号，并不是说时钟一定就要是固定频率的方波信号——毕竟 TIM 本质就是一个计数器，所以它也可以当作计数器来用。在这种意义上外部时钟功能非常适合外部传感器计数等类似场景。

> 查看引脚定义可以知道 TIMx_ETR 的来源（不同型号不同，下面是以 STM32F103C8T6 为例），例如 PA0 的默认复用功能一栏写着“WKUP /  USART2_CTS / ADC12_IN0 / TIM2_CH1_ETR”，最后这个 TIM2_CH1_ETR  就代表该引脚（PA0）是通用定时器 TIM2 的 CH1 和 ETR 的复用引脚。TIM2_CH1 见后，属于框图的下半部分；另一个就是  TIM2_ETR，也就是 TIM2 的外部时钟来源。

看框图，使用外部时钟还需要配置一下内部的“极性选择、边沿检测和预分频器”以及“输入滤波”电路。**输入滤波**用于对外部电路进行一定整形，减少外部输入信号毛刺的影响，毕竟它一般没有正经的时钟信号稳定。**极性选择和边沿检测**好像是一回事，总之就是选择检测信号变化的方式，例如选择上边沿检测。**预分频器**还是起分频作用，不过分配范围小一些，只能指定 1、2、4、8 分频（用两位寄存器控制）。

> **输入滤波和分频因子**：这里用的方法是利用固定时间间隔采样，如果多次采样稳定那么说明信号稳定；如果不稳定则保持或固定某个输出，以达到一定程度滤波的效果。所以滤波器有采样频率 f 和采样点数 N 这些参数，频率越低、采样点数越多，则滤波效果越好，但相应地，信号延迟会增大。采样频率 f  可以直接来自内部时钟，也可以是内部时钟再加个分频得到——这个分频系数就是后面会提到的**分频因子**，即库函数那里的 ClockDivision 参数。

滤波后的信号一路通过 ETRF 进入触发控制器，然后流出并连接到时基单元，这一路叫做“**外部时钟模式 2**”。走 ETR 这一路具体展开的框图见下：

![img](https://pic3.zhimg.com/80/v2-dc59336150acbff08ff58afd3b3a33a2_720w.webp)

外部时钟模式 2 即走 ETRF 那一路的框图（图的标题感觉翻译错了……？好像走 TRGI 才是触发输入，ETRF 就是普通的外部输入）

那么对应一定还有个“**外部时钟模式 1**”，这一路对应的是框图中走 TRGI 的那一段。

![img](https://pic2.zhimg.com/80/v2-184dc7da7047053fcdfa656616125351_720w.webp)

外部时钟模式 1 即走 TRGI 那一路的框图

我们通过观察中间的选择器，看下它的来源：首先最后一个 ETRF 就是从 ETR 一路走过来的外部时钟信号，它分一路走了 ETRF（即前面的模式 2），还分一路走了 TRGI ——对于从 ETR 来的信号，走这两路是一样的，没有影响，只不过后者会占用触发输入的通道；其他的 ITRx、TI1_ED、TI1FP1、TI2FP2 和大框图中也是一一对应的。

**ITRx** 来自其它定时器，也即“**内部触发输入模式**”。

> 这些模式名字的分类和包含关系个人感觉看手册说得有一点模糊。但这个不影响，重点是硬件实现，分类只是概念上的问题。

从大框图的右上角可以看到输出的 TRGO“至其它定时器、至 DAC / ADC”，显然 ITRx 就是来自其它定时器的 TRGO 输出。ITRx 包含 ITR0、1、2、3  四条连接，意味着可以有四个 TIM 的 TRGO 输出接入该 TIM，而具体的连接方式参考手册从模式控制寄存器最后的一张表：

![img](https://pic3.zhimg.com/80/v2-06e15e59f851333fbe172b21b09177a2_720w.webp)

ITRx 与 TIM 的具体连接方式（内部触发连接表）

> 举个例子，实现前面提到的 **TIM 级联**。例如，我们先初始化 TIM3，然后使用主模式把它的更新事件映射到 TRGO。然后看上表，TIM3 的TRGO 连接到了 TIM2 的 ITR2  上，所以我们接下来初始化 TIM2，选择 ITR2 通道，并选择外部时钟模式 1，就完成了 TIM3 到 TIM2 的级联。

再看大框图，**TI1_ED** 来自输入捕获单元的 CH1 引脚。这个 ED 就是 Edge 的意思，即它从 TIMx_CH1 接收上升、下降沿均视为有效的信号。最后是 **TI1_FP1** 和 **TI2_FP2**，看大框图发现它们分别来自 CH1、CH2 引脚的时钟。具体见后**输入捕获**功能。

总结来说，**外部时钟模式 1** 的输入可以来自：外部信号 ETR、其他时钟 ITR、CH1 引脚边沿、CH1 引脚和 CH2 引脚。最常用的还是外部 ETR 输入，其它的一般为特殊应用场景而设计，例如前面提到的定时器级联。后面几个在之后其它功能中具体说明。**外部时钟模式 2** 就是外部输入 ETR 专用，外部时钟一般都用它，和走模式 1 的 ETR 区别不大。对于普通时钟应用场景，最常用的自然是主频 72MHz **内部时钟模式**。

**【输入捕获与输出比较】**输入捕获部分位于大框图左下部分，可以用于检测方波频率等。输出比较部分对应大框图的右下部分，可以用于输出 PWM 波形驱动电机。捕获和比较都有四条通道，对应的都是 TIMx_CH1 到 TIMx_CH4 引脚，具体哪个定时器的哪个 CH 对应的实际上的哪个引脚，查引脚复用表即可。中间的部分是捕获 / 比较寄存器，为二者共用（捕获和比较不能同时使用，所以寄存器和引脚也可以共用）。

先说**输出比较**（Output Compare，OC）：输出比较用于输出 PWM 波形，用以驱动电机等。**原理**上来说，它通过**比较 CNT 和 CCR 寄存器值的关系**，对输出电平进行置 1、置 0 或翻转的操作，以**输出一定频率和占空比的 PWM 波形**。每个通用或高级定时器都有四个输出比较通道，高级定时器的前三个还额外有死区生成和互补输出的功能。

> PWM 即 Pulse Width Modulation，脉冲宽度调制。PWM 是一串数字信号，也是由高低电平组成。在**具有惯性的系统**中，可以通过对一系列脉冲的宽度进行调制，来**等效**地获得所需要的**模拟参量**。直白了说就是快速、分段、不均匀地输送能量，让负载工作在完全高和完全低电平以外的中间状态，用这种方式来使数字信号达到模拟信号的等效效果（或者说其实是一个类似积分的过程）。需要强调的是一定要是具有惯性的系统，大概就是它需要自己起到一个滤波的作用。
> PWM 有一些常规的参数。一段高电平一段低电平合起来的一段，就是一个高低电平变换的周期，记为 

 ，其倒数  就称为 PWM 波形的**频率**。这段周期中高电平的时间段记为  ，余下低电平的时间段记为  ，定义**占空比**为 

>  ，即高电平时段在一周期内的占比。还有**分辨率**被定义为占空比变化步距，也就是占空比可以以多小的单位进行变化，比如以 1% 的步距跳变，就不会有 0.1% 级别精度的占空比出现。
> PWM 的频率越快，等效的模拟信号就越稳，当然性能开销也就越大，一般几到几十千赫兹就差不多了。占空比决定的是等效出的模拟电压值大小，这个关系一般是线性的。高分辨率会对硬件电路提出要求，一般来说普通应用 1% 也就够了。
> PWM 除了用于等效模拟信号，有时也可以作为通信协议（并且只需要一根线）。例如驱动舵机时，舵机会根据输入的 PWM 波形将占空比将输出轴稳定在一个角度。

仔细来看上面的原理，CNT 就是时基单元的计数器，CCR 则是“**捕获 / 比较寄存器**”，在大框图中 CNT 的下方。这些寄存器是输入捕获和输出比较单元**共用**的，因为前面提过一个通道是不能同时复用两个功能的。

> 简写 CC，即 Capture / Compare，表示的是输入捕获和输出比较的单元。CCR 就是加上一个 Register，寄存器。

![img](https://pic1.zhimg.com/80/v2-b38a56fd9f21f803608a4c44423ef4c0_720w.webp)

通用定时器捕获 / 比较通道的输出部分框图

上图表示的就是通用定时器（的第一路）输出比较部分的电路框图。我们从图中可以看到之前所谓的“比较 CNT 和 CCR 寄存器值的关系”是什么意思（最左侧）。当 CNT 大于或等于 CCR1（其他通道就是 CCRx）时，就会给**输出模式控制器**传递一个信号，然后输出模式控制器就会改变其输出 oc1ref 的高低电平。

oc1ref 主干流向右侧的部分，是一个**极性选择器**，给 CC1P 写 0 就不反转，写 1 就会把信号反个相。然后流入**输出使能电路**，由 CC1E 位控制是否要输出。最后输出给 OC1 引脚，同样地，这些复用功能引脚可以在引脚复用表找 TIMx_CHx 来确定具体是指哪个 GPIO 脚。

> 框图左上角的 ETRF 是代表了定时器的一个不常用小功能，暂略【TODO】。
> 以及看框图可以知道这个 oc1ref 是可以主模式映射到 TRGO 输出上的。

关于**输出模式控制器的具体工作方式**。输出模式控制器有八种模式，分别就代表给高、低电平的不同规则，查手册可以得到输出比较模式表：

![img](https://pic2.zhimg.com/80/v2-6e5e2d33e9bf039bcb316ef1a9e92cd9_720w.webp)

OC1M 控制的输出比较模式选择表

或者更清晰的：

![img](https://pic2.zhimg.com/80/v2-64a4b6f87cfae9771cbb49c608366229_720w.webp)

引自文末参考视频

所以比较它们俩的过程有点像这种感觉：

![img](https://pic4.zhimg.com/80/v2-70c194acfec94eb964db845714c58907_720w.webp)

累加循环的 CNT 和 设置的 CCR 进行比较，在不同节点表现不同行为，从而生成波形

就用这种方式画，并且对照着上面的表，就能画出相应的波形长什么样子了。

再来说下上面的表。**冻结**就是维持状态不变，一般是一种“暂停”操作。下面两个**匹配时置某电平**，都是比较等于的情况，一般不用于输出连续变化波形，可能可以用于生成一次性的信号。**匹配时电平翻转**可以方便地生成一定占空比的波形。**强制为某电平**，例如在暂停期间保持某个特定电平可以用。

比较重要的是 **PWM 模式 1** 和 **PWM 模式 2**，它们可以用于输出频率和占空比都可调的 PWM 波形，也是生成 PWM 波形最主要使用的模式。首先观察可以发现 PWM 模式 2 就是 PWM 模式 1 反相，我们可以只管模式  1；然后向上、向下计数本质上差不多，我们一般都用向上计数，所以我们单独看一个模式 1 的向上计数情况即可。

在 PWM 模式 1 的情况下实际上就是 CNT 低于 CCR 就高电平，CNT 高于或等于 CCR 时就低电平。然后 CNT 不断累加，到 ARR（自动重转载）的值就轮回来，继续往复，从而生成了相应的波形：

![img](https://pic2.zhimg.com/80/v2-e67243f37e43dc8281bb773041751565_720w.webp)

生成高低电平波形

所以前面说**频率可调**就是通过调整 ARR 可以调整 REF 的周期长度，**占空比可调**就是通过调整 CCR 可以调整高电平的持续时长。

> **【PWM 参数和寄存器值的关系计算】**
> 频率 Freq = CK_PSC / (PSC + 1) / (ARR + 1)，也就是和前面更新频率（溢出频率）相等的。
> 占空比 Duty = CCR / (ARR + 1)。
> 分辨率 Reso = 1 / (ARR + 1)。

然后是**输入捕获**（Input Capture，IC）：

不详细说明，可以从通道引脚捕获边沿。







### （3）高级定时器

惯例先看一下大框图：

![img](https://pic4.zhimg.com/80/v2-2e78124439e6e065fe4bee6dd337de2b_720w.webp)

高级定时器的结构框图

可以看到左上角的大部分和通用定时器一致，即代表包含通用定时器的所有功能。下面来看一些多出的功能：

**【重复计数器】**看大框图时基单元产生中断的部分，添加了一个重复次数计数器，作用是可以实现在多个计数周期后再触发中断，可以说相当于对输出的更新信号又进行了一次分频。相关的控制寄存器是 16 位的，所以可以在之前那个 59 秒多的最大时长上再乘一个 65536 大幅延长单个 TIM 的计时上限，而不用使用定时器的级联。

**【互补输出与死区生成】**看框图可以发现，右边的输出引脚从每通道一个，变为了两个互补的输出。这是为了可以输出一对 PWM 波，用以驱动三相无刷电机。而互补信号在电平跳变时因为器件不理想，可能造成短暂的直通现象（一个跳高一个跳低产生短暂交错），所以要在前面加上 DTG 即死区生成电路，在跳变时直接全部关断，产生“死区”，跳过这段可能出问题的部分。以及，因为三相电机只要三路，所以框图中显示也只有前三个通道加上了 DTG。

![img](https://pic1.zhimg.com/80/v2-854448500f00246e967bba771cbbe204_720w.webp)

高级定时器输出比较部分电路结构框图

> 至于互补信号的作用，是为了满足外部电路类似 CMOS  的结构的需求，对上下两个开关管施加反相的信号。为了不浪费输出引脚于是有了互补输出的功能。死区生成就是辅助互补输出，使其不易在跳变时造成短暂的“直通现象”（比如上下开关管暂时性同时导通导致短路等）而出现的一项功能。

**【刹车输入】**用以给电机驱动提供安全保障，对应框图左下角的部分。如果外部引脚 TIMx_BKIN（Break in 的简写）产生了刹车信号（或门第一条线），或内部时钟失效产生故障（或门第二条线，时钟失效也就是时钟树中的  CSS 即时钟安全系统监测到了时钟错误），那么控制电路将自动切断电机输出，防止意外。

> 当然还有许多其他功能，此处暂略。







## 三、TIM 寄存器定义概述

> 仅概述，具体参考手册。

### （1）基本定时器

**控制寄存器 1**（TIMx_CR1）：设置自动重装载预装载、计数器的使能，单脉冲模式（发生一次更新时间就停止），更新请求源（计数器溢出以外的一些触发更新的方式），禁止更新（不产生更新事件）。

**控制寄存器 2**（TIMx_CR2）：主模式选择（选择主模式映射到 TRGO 的功能）。

**DMA / 中断使能寄存器**（TIMx_DIER）：使能或失能中断、DMA 请求的发送。

**状态寄存器**（TIMx_SR）：硬件用于标记表示是否产生更新中断的状态，由软件清除（即需要在中断程序中手动清除），这一点和 EXTI 中挂起寄存器的标志位类似。

**事件产生寄存器**（TIMx_EGR）：设置产生更新事件（置 1 则会重新初始化计数器并产生对寄存器的更新）。由软件设置，硬件自动清除。

**计数器**（TIMx_CNT）：计数器的即时数值。

**预分频器**（TIMx_PSC）：预分频器的分频系数，注意实际分频系数加一。

**自动重装载寄存器**（TIMx_ARR）：设置自动重装载数值。如果是 0 则计数器停止。







### （2）通用定时器

**控制寄存器 1**（TIMx_CR1）：设置时钟分频因子（也就是前面通用寄存器部分以及后面第一个库函数实现部分提到的 ClockDivision 参数，表示滤波器采样频率的分频）、自动重装载预装载允许位（再重复一下这个预装载就是缓冲机制，可以选择关闭或开启，也就是修改值后是否立即生效）、计数模式（边沿对齐还是中央对齐）、计数方向（边沿对齐时选择向上还是向下，否则只读）、单脉冲模式、更新请求源、禁止更新、计数器使能。

**控制寄存器 2**（TIMx_CR2）：设置 TI1 选择、主模式选择（功能比基本定时器多一些）、捕获 / 比较的 DMA 选择（发送 CCx 的 DMA 请求的条件）。

**从模式控制寄存器**（TIMx_SMCR）：设置外部触发极性（高电平上升沿有效还是低电平下降沿有效）、外部时钟模式 2 使能、外部触发预分频系数（见外部时钟输入模式 2 的分频器）、外部触发数字滤波器（设置采样频率和点数，意义见前滤波的解释）、主 / 从模式、触发选择（就是外部输入时钟那的大选择器）、从模式选择。

**DMA / 中断使能寄存器**（TIMx_DIER）：设置是否触发 DMA 和中断请求以及各 DMA 和中断源各自的使能与失能（更新的、捕获 / 比较的）。

**状态寄存器**（TIMx_SR）：重复捕获标记、触发器中断标记（来自触发事件，见大框图外部输入选择器那里的 TGI 箭头，即 Trigger Interrupt）、捕获 / 比较端的中断标记、更新中断标记。

**事件产生寄存器**（TIMx_EGR）：手动产生事件，软件设置，硬件清除。可以手动产生的除了基本定时器的更新事件以外还有多出来的捕获 / 比较事件以及触发事件。

**捕获 / 比较模式寄存器 1**（TIMx_CCMR1）：暂略。

**捕获 / 比较模式寄存器 2**（TIMx_CCMR2）：暂略。

**捕获 / 比较使能寄存器**（TIMx_CCER）：暂略。

**计数器**（TIMx_CNT）：同前。

**预分频器**（TIMx_PSC）：同前。

**自动重装载寄存器**（TIMx_ARR）：同前。

**捕获 / 比较寄存器 1**（TIMx_CCR1）：暂略。

**捕获 / 比较寄存器 2**（TIMx_CCR2）：暂略。

**捕获 / 比较寄存器 3**（TIMx_CCR3）：暂略。

**捕获 / 比较寄存器 4**（TIMx_CCR4）：暂略。

**DMA 控制寄存器**（TIMx_DCR）：暂略。

**连续模式 DMA 地址**（TIMx_DMAR）：暂略。







### （3）高级定时器

比前面多一个寄存器来管理刹车输入和死区生成等功能。







## 四、具体实现案例（标准库 + HAL）

### （1）定时中断

![img](https://pic2.zhimg.com/80/v2-efc870539a3caaeb7f5cd49bed82d1ad_720w.webp)

来自文末参考视频

该图把定时中断功能需要的部分从框图中单独提取出来了，大致就是包含来源、时基单元和终端输出三块。

多出来一个“**中断输出控制**”部分，它有点类似 EXTI 的中断控制。因为定时器内部有大量的中断源，这部分就负责放行或禁止一些中断。如果我们需要某个中断触发，需要在这里配置一下允许放行。

这里实现一个使用内部时钟源的 TIM 定时中断功能。

**【标准库实现】**按步骤走通上述框图中的路径即可：

1.  国际惯例，RCC 开启时钟。
2. 选择时基单元的时钟源，这里就直接使用内部时钟源。
3. 配置时基单元，即配置预分频系数、计数模式、自动重装载值等。
4. 配置输出中断控制，允许更新中断传递给 NVIC，也就是前几行提到的中断输出控制部分。
5. 配置 NVIC，在 NVIC 中打开定时器中断的通道，并分配优先级。这部分是属于中断的内容，当然，后边还要写个中断函数。
6. 运行控制。使能定时器，定时器才会开始计数。

按顺序来，首先是 TIM_DeInit 恢复默认配置，需要的话就用一下，刚复位应该不用。

然后第一步开启时钟，如果是通用定时器那是挂在 APB1 上的，所以直接 RCC_APB1PeriphClockCmd。以通用定时器 TIM2 为例：

```c
RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
```

第二步选择时钟源，有多个函数，对应都可见上框图：

```text
TIM_InternalClockConfig 使用内部时钟
TIM_ITRxExternalClockConfig 使用 ITRx 即其它定时器的时钟
TIM_TIxExternalClockConfig 使用 TIx 捕获通道的时钟，按前文这里还可以进行极性选择和滤波器
TIM_ETRClockMode1Config 使用走外部时钟模式 1 路线的 ETR 时钟
TIM_ETRClockMode2Config 使用走外部时钟模式 2 路线的 ETR 时钟，如果不需要触发输入的功能，这个和前一个可以互换
TIM_ETRConfig 不是用于选择时钟，是用于单独配置 ETR 的预分频器、极性、滤波器等参数
```

那么我们这里配置为内部时钟源：

```c
TIM_InternalClockConfig(TIM2);
```

> 这里有一点，定时器上电后默认使用内部时钟，所以这句实际上可以不写，不过写了更清晰完整。

第三步，函数 TIM_TimeBaseInit 使用结构体初始化时基单元，TIM_TimeBaseStructInit 可以给这个结构体赋上默认值。

> 前面提到过，时基单元有些参数例如分频系数、重装载值等都是**可以在运行时修改**的，而如果每次都用一下 Init 函数未免麻烦。所以标准库还提供了 TIM_PrescalerConfig 单独更改**预分频系数**（还可以选择是当前周期结束生效还是立即生效，立即生效的原理是手动产生更新事件结束当前周期），TIM_CounterModeConfig 单独更改计数器**计数模式**，TIM_ARRPreloadConfig 单独更改**自动重装载器预装功能**配置（也就是缓冲机制），TIM_SetCounter 单独直接给**计数器写值**，TIM_SetAutoreload 单独修改**自动重装载值**。
> 还有一些 GET 类的函数，例如 TIM_GetCounter 获取当前计数器值，TIM_GetPrescaler 获取当前预分频器系数。以及用于**获取和清除标志位**的 TIM_GetFlagStatus、TIM_ClearFlag、TIM_GetITStatus 以及 TIM_ClearITPendingBit。

我们如上进行配置（参数配置以定时 1s 为例）：

```c
TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; // 分频因子，这里就选不分频了
// 这里的分频因子其实和时基单元关系不大，具体见上文通用定时器部分某段灰字“输入滤波和分频因子”
TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; // 计数模式，这里选个向上计数
TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; // 预分频系数，这里写个 7200 分频，得到 10kHz
TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; // 周期，即 ARR 自动重装载器的值，在前面得到的 10kHz 下计数 10000 次，得到 1s
TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; // 重复计数器值，这个是高级定时器里的，TIM2 用不到，这里直接写个 0
TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);
```

第四步，函数 TIM_ITConfig 用于使能中断输出信号（标准库中使能外设中断输出的函数基本都长这样），开启更新中断到 NVIC 的通路：

```c
TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE); // 这里选择更新中断，使能之
```

> 要注意的是这里不同于 NVIC 配置，这里配置的是 TIM 输出端的中断控制模块，所以后面 NVIC 处开启通道是不够的，也要用这句开启输出的闸门。

第五步配置 NVIC，用中断部分的 NVIC_Init 函数，复习一下中断配置：

```c
NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
NVIC_InitTypeDef NVIC_InitStructure;
NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; // 开启 TIM2 的中断通道
NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; // 使能
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; // 抢占优先级
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; // 响应优先级，以上数值根据需要配置，仅为举例
NVIC_Init(&NVIC_InitStructure);
```

第六步，函数 TIM_Cmd 用于使能计数器（设置计数器开启状态）：

```c
TIM_Cmd(TIM2, ENABLE);
```

然后写中断函数，查表得知我们应该覆写 void TIM2_IRQHandler(void)：

```c
void TIM2_IRQHandler(void) {
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET) { // 检查一下更新标志位
		// User Code
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update); // 记得手册里提到这里要手动清除标志位。
	}
}
```

> 一个细节问题，关于一上电，TIM **初始化完就立刻进入一次中断**：原因在于 TIM_BaseInit 函数实现的末尾手动触发了一次更新事件（TIMx->EGR = TIM_PSCReloadMode_Immediate），目的是使预分频器这种有缓冲机制的部分立即生效。但**更新事件和更新中断是同时发生的**，这也就导致了调用这个函数后，虽然更新事件达到了使寄存器生效的目的，但中断标志位也直接就被置位了。然后到后面开启中断控制通道，并且配置完 NVIC 之后，中断就会立刻被触发。**解决方法**就是函数结束后在外面手动清一下中断标志位即可，位置在 TIM_BaseInit 之后，中断配置之前：TIM_ClearFlag(TIM2, TIM_FLAG_Update)。
> 然后稍微提一下**更新事件**、**更新中断**和**更新标志位**的关系（以通用定时器为例）：中断和事件的概念和外部中断中是类似的，即事件一般是硬件层面直接将触发的信号传递给其它部分，高速协同工作；中断则是走 NVIC 渠道打断 CPU  让软件来处理。更新事件和更新中断也类似，二者都是在定时器到点之后触发，然后定时中断走中断渠道，定时更新的信号基于硬件输送到各地（例如主模式映射到 TRGO，更新影子寄存器等等）。然后是更新标志位，查手册可以看到 TIM 有个状态寄存器，位 0 即 UIF  更新中断标记，并且只有一个，事件和中断触发一起用。定时器到点触发后就硬件自动置位这个标志位，然后**需要程序手动清除**。



**【HAL 库实现】**原理肯定和库函数是一样的，实现也不会有多大差别。我们直接 CubeMX 图形化配置一下，然后看它生成的代码。

首先配置 SYS 和 RCC 就不用说了。然后选择 TIM2 按照前面的知识配置好相关参数：

![img](https://pic1.zhimg.com/80/v2-c5eadbc0f96ad3bfdf0fd25472acc7d8_720w.webp)

TIM2 的图形化配置

记得把 NVIC 通道给它打开：

![img](https://pic3.zhimg.com/80/v2-3968b38517f5d61852835f294c1e8bca_720w.webp)

NVIC 通道配置，这忘写优先级了，也可以改

首先是 HAL 必不可少的句柄：

```c
TIM_HandleTypeDef htim2;
```

接下来看下 HAL_TIM_Base_MspInit 函数，里面包含了 **TIM2 时钟的使能**和 **NVIC 的设置**：

```c
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle) {
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	if (tim_baseHandle -> Instance == TIM2) {
		__HAL_RCC_TIM2_CLK_ENABLE();
		HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
		HAL_NVIC_EnableIRQ(TIM2_IRQn);
	}
}
```

然后是 MX_TIM2_Init 函数，里面包含了**时基单元的基本配置**（和标准库基本长得一样），以及**时钟源的选择**（那个 INTERNAL）：

```c
// 后面主从模式是 DISABLE 的，只是代码生成了
void MX_TIM2_Init(void) {
	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
	TIM_MasterConfigTypeDef sMasterConfig = {0};

	htim2.Instance = TIM2;
	htim2.Init.Prescaler = 7200 - 1;
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim2.Init.Period = 10000 - 1;
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK) Error_Handler();

	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) Error_Handler();

	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK) Error_Handler();
}
```

并且给你留好了中断函数的位置（并且标志位的管理 HAL 是帮你做好的，详见 HAL_TIM_IRQHandler 的 /* TIM Update event */ 注释处）：

```c
void TIM2_IRQHandler(void) {
	HAL_TIM_IRQHandler(&htim2);
	// ...
}
```

嗯，是不是还少了些什么？对，相比前面的做法还少了一个第四步，使能 TIM 的中断控制。在初始化都完成后用如下函数开启它：

```c
HAL_TIM_Base_Start_IT(&htim2);
```

点进去找这个函数的具体实现就能看到它里面的 __HAL_TIM_ENABLE_IT 在对 DIER 寄存器进行操作。

唔，还有件事，前面还有过一个**细节问题**，即一上电 TIM 初始化完就立刻进入一次中断的问题（比如做了个计时器都是从 1 开始数）。前面说过原因了，解决方法就是初始化完之后把中断标志位噶了。那么在 HAL 中也类似，初始化完成之后，在 HAL_TIM_Base_Start_IT **启动中断之前**加上一句清除标志位即可：

```c
__HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);
```







### （2）外部时钟源选择

我们使用 TIM2 的 ETR 引脚（查表可知 STM32F130C8T6 中是 PA0 引脚）接受外部传感器（例如对射式红外传感器）传来的方波信号，上升沿表示有效计数。

**【标准库实现】**和前面例子大体没有太大区别，就改下时钟源选择就可以了。

具体来说就是，删掉前面配置内部时钟源的这一行：

```c
TIM_InternalClockConfig(TIM2);
```

然后换成选择外部时钟的函数：

```c
TIM_EETRClockMode2Config(TIM2, TIM_ExtTRGPSC_OFF, TIM_TxtTRGPolarity_NonInverted, 0x00);
// 四个参数第一个是选择配置 TIM2
// 第二个是不对外部时钟输入进行预分频
// 第三个是极性选择，选了个不反相（也就是上边沿或高电平有效）
// 第四个是选择滤波器的采样频率和采样点数，具体对应关系手册有，这里就写个不需要了
```

**还有一件重要的事情**，就是这里使用了 PA0 复用为 TIM2 的 ETR 引脚，所以要记得配置 GPIO 引脚，以及开启 GPIO 的时钟，也就是在前面：

```text
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
... // 配置引脚信息结构体，略
GPIO_Init(GPIOA, &GPIOInitStructure);
```

查看手册 GPIO 节可以查看对于 TIM 的 ETR 引脚，推荐配置是**浮空输入**模式。

> 浮空输入模式电平可能不稳定，所以也可以使用上拉输入模式。如果**外部输入信号的功率很小**，内部上拉电阻可能会影响到这个信号，这时就可以使用浮空输入模式，对输入信号影响更小。

当然，定时器配置也改一下，改小点，毕竟传感器是手动，计那么多次才触发没必要。



**【HAL 库实现】**也只要一些小改动，CubeMX 打开 .ioc 文件新配置下 GPIO 什么的，然后切换下时钟输入源即可。

![img](https://pic2.zhimg.com/80/v2-4b830f5b502fe0c85fb3435f22672301_720w.webp)

新的配置

上图是修改后的配置，可以看到我们把时钟源改成了 ETR2，这个就是对应的外部时钟源模式 2。

然后下面设定好时基单元，以及外部时钟的几个参数（可以看到和库函数都是对应的）。

我们需要一个引脚来接收外部时钟，所以要去 GPIO 配置好 PA0（TIM2_ETR，而且 CubeMX 可以直接选择引脚的复用功能，不用手动配置，会帮你自动配好默认推荐配置）。

最后，NVIC 别忘了开。然后就好了，运行即可。

实际实现时接了一个对射式红外传感器，出现了一些小问题，即信号很不稳定，挡光一次计数器连加好几次。不太清楚视频中为啥挺稳定的，可能是一些环境原因。所以我们可以修改上图中的 Clock Filter 部分，使用其内部的数字滤波器来平稳信号（原理前面提过了）。具体的赋值查手册有下表：

![img](https://pic3.zhimg.com/80/v2-411c00d13328c1da8ead20329a1e076e_720w.webp)

数字滤波器参数对应表

我选了个差不多的 0101（即十进制 5），然后就非常稳定了，挡光一次加一。







### （3）利用输出比较功能输出 PWM 波形

输出 PWM 的基本流程结构如下图：

![img](https://pic2.zhimg.com/80/v2-b3c09e0eb56a8dd0e1bf6f921d31a239_720w.webp)

来自文末参考视频，以 PWM 模式 1 为例

和前面例子不同的就是我们这里不用触发中断了，而是利用输出比较部分输出波形。所以除了中断部分，前面的内容是一样的，并且需要添加输出比较部分的配置。

我们仍然使用**通用定时器 TIM2**，查表得知 STM32F103C8T6 中 **PA0 口**就是 TIM2 第一个输出比较通道（OC1）的复用引脚（TIM2_CH1，输出比较和输入捕获的引脚和寄存器是共用的）。

以产生一个**频率 1kHz，占空比 50%，分辨率 1% 的 PWM 波形**为例。按前面的公式可以算得几个需要配置的值：**PSC 为 720 - 1，ARR 为 100 - 1，CCR 为 50**。

> （重复一下前面的）
> **【PWM 参数和寄存器值的关系计算】**
> 频率 Freq = CK_PSC / (PSC + 1) / (ARR + 1)。
> 占空比 Duty = CCR / (ARR + 1)。
> 分辨率 Reso = 1 / (ARR + 1)。

**【标准库实现】**仍然是按步骤配置：

1.  RCC 开启 TIM 和 GPIO 时钟，选择时钟源（这里和定时中断案例一样，选用内部时钟源即可），配置时基单元，这部分和前面一样。
2.  配置输出比较单元，包括 CCR 的值、输出比较模式、极性选择和输出使能等。
3.  配置 GPIO 引脚为复用推挽输出模式。
4.  运行控制，启动定时器。

第一步就略了，和前面一样（打开中断和配置 NVIC 的部分不再需要）。

> 按新的要求定时器的 ARR 和 PSC 要按上面计算的值改一下。

第二步配置输出比较单元。输出比较共有四个通道，其标准库中的初始化函数对应为 TIM_OCxInit（x 为 1、2、3、4），参数是 TIM 的索引和一个结构体，可以用 TIM_OCStructInit 给它赋一个默认值。

```c
TIM_OCInitTypeDef TIM_OCInitStruture;

// 这里其它一些例如 .TIM_OCIdleState、.TIM_OCNIdleState、.TIM_OCNPolarrity 等参数是高级定时器才用的，
// 通用定时器用不到，而这些局部的参数不赋初值则值不稳定，所以最好加一句这个，赋一个初始值：
TIM_OCStructInit(&TIM_OCInitStruture);

TIM_OCInitStruture.TIM_OCMode = TIM_OCMode_PWM1; // 输出比较模式，设置为 PWM 模式 1
TIM_OCInitStruture.TIM_OCPolarity = TIM_OCPolarity_High; // 极性选择，设置为高极性（REF 不翻转）
TIM_OCInitStruture.TIM_OutputState = TIM_OutputState_Enable; // 输出使能，设置使能
TIM_OCInitStruture.TIM_Pulse = 50; // CCR，前面计算得 50
TIM_OC1Init(TIM2, &TIM_OCInitStruture);
```

> 除此之外是一些**细节功能**：
> TIM_ForcedOCxConfig 用于配置强置输出模式（不常用，因为可以用 0% 或 100% 占空比的 PWM 信号替代）。
> TIM_OCxPreloadConfig 用于配置 CCR 寄存器的预装功能（即影子寄存器，缓冲机制）。
> TIM_OCxFastConfig 用于配置快速使能（TIM 的单脉冲模式指就进行一个计数周期，不循环，配合 PWM  模式就可以实现在检测到信号后延迟一段时间产生一段电平信号。快速使能是它的一个特殊功能，可以避免一些前置操作对最小延时时间的限制，具体见手册单脉冲模式部分）。
> TIM_ClearOCxRef 对应手册中外部事件时清除 REF 信号的部分。
> 还有个比较重要的，TIM_CtrlPWMOutputs **用于高级定时器**输出 PWM 时使能主输出，否则它不会正常输出。
> 和一些**运行时修改参数**的函数：
> TIM_OCxPolarityConfig 和 TIM_OCxNPolarityConfig 用于单独设置输出比较的极性（带 N 表示高级定时器中的互补通道，而 OC4 没有互补通道，所以 OC4 也就没有 OC4N 的那个函数）。
> TIM_CCxCmd 和 TIM_CCxNCmd 用于单独设置输出使能。
> TIM_SelectOCxM 用于单独修改输出比较模式（这里的 x 是真 x，不代表数字，通道序号在参数里）。
> TIM_SetComparex 用于单独更改 CCR 寄存器的值（相当于即时修改占空比，所以这个比较重要）。

第三步配置 GPIO 也略了，要配置的引脚为 PA0，模式为复用推挽输出模式（GPIO_Mode_AF_PP）。这里涉及到 GPIO 部分的内容，使用“复用”打头的模式，物理含义就是断开 GPIO 的输出数据寄存器，使用来自片上外设的复用功能输出，具体参见 GPIO 结构框图。

第四步就是一样地使能定时器了：

```c
TIM_Cmd(TIM2, ENABLE);
```

然后就能输出频率 1kHz，占空比 50%，分辨率 1% 的 PWM 波形了。然后如果要实现类似呼吸灯的效果，就要**实时改变占空比**。可以利用前面提到的 SetComparex 函数单独设置 CCR 的值，来更改占空比。

> 根据前面的内容，占空比不止由 CCR 决定，而是由 CCR 和 ARR + 1 共同决定。我们这里固定了 ARR + 1 为 100，才使得 CCR 直接为占空比。

TIM2 的输出比较通道一对应引脚为 PA0，如果它有其他用途，查看引脚定义表可以发现，TIM2_CH1 可以**重映射**到 PA15 的位置。重映射功能由 AFIO 管理，所以需要使能 AFIO 外设，然后使用 GPIO_PinRemapConfig 函数进行重映射（方式查看手册）：

```c
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // 使能 AFIO 时钟

GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE); // TIM2_CH1 -> PA15
GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
// 因为 PA15 在上电后默认复用为 JTDI 调试端口，所以还需要关闭这个调试端口的复用
// 使用该句重映射就会禁用 JTAG 调试，也就是 PA15、PB3 和 PB4 取回了 GPIO 的功能
```

如果重映射到了 PA15 那么后面配置 GPIO 的时候也要改成配置 PA15。



**【HAL 库实现】**流程类似。

RCC 使能时钟在 CubeMX 中配置即可。

对于 GPIO 引脚，在 CubeMX 中配置 PA0 为 TIM2_CH1  就自动帮你规范好了基本配置，只需要改改引脚速度和模式，模式也给你限定了复用推挽或开漏，选复用推挽即可。然后在 tim.c  中（如果没选拆分代码就在 main.c）就生成了相关配置的代码了。

时基单元和时钟源的配置和定时中断差不多，时基单元的参数按前面的计算结果即可，并且选择 PWM Generation CH1 模式，也就是通道一的 PWM 输出模式（选择后下面还可以配置是模式 1 还是模式 2）：

![img](https://pic3.zhimg.com/80/v2-1f99822cd04e6fa294bd29c8f0c9d1a6_720w.webp)

TIM2_CH1 即 PA0 引脚的配置

然后在 MX_TIM2_Init  函数中就能看到代码了，用的函数也类似，基本看名字就认识了：HAL_TIM_Base_Init、HAL_TIM_ConfigClockSource、HAL_TIM_OC_Init、HAL_TIM_OC_ConfigChannel 之类的。

最后就是运行控制，使能 TIM2 开始计时即可。HAL 中使用如下函数启动 TIM2（注意使用 PWM 模式时有专门的函数，和中断控制那里不一样）：

```c
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
```

当然，想同时触发中断也是可以的，NVIC Settings 中打开 TIM2 全局中断，写好中断函数，然后同时使用 HAL_TIM_Base_Start_IT 开启中断控制即可。

以及，如果是要实现**呼吸灯**这样的效果，那么在 HAL 中可以使用 __HAL_TIM_SET_COMPARE 来即时改变 Pulse（即 CCR），从而改变 PWM 波形的占空比：

```cpp
...
while (true) {
	for (int i = 0; i <= 100; i ++) {
		__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, i);
		HAL_Delay(10);
	}
	for (int i = 0; i <= 100; i ++) {
		__HAL_TIM_SET_COMPARE(&htim2, TIM_CHANNEL_1, 100 - i);
		HAL_Delay(10);
	}
}
...
```

> HAL 的注释不像标准库那么全，可以直接点进去查，所以可能记一下规律比较好。比如这类 Setter 和 Getter 函数一般都是两个下划线打头的宏定义函数。